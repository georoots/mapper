<!-- 
GNU GENERAL PUBLIC LICENSE
Version 3, 19 November 2007

Copyright (C) 2025 GeoRoots

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Mapper - GeoRoots</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* CSS Variables for consistent color scheme */
        :root {
            --primary-color: #1b4332;
            --secondary-color: #40916c;
            --accent-color: #efffef;
            --dark-color: #1b4332;
            --light-color: #f8f9fa;
            --danger-color: #dc6575;
            --confirm-color: #40916c;
            --text-color: #333;
            --border-color: #e9ecef;
            --shadow-color: rgba(0, 0, 0, 0.1);
            
            /* Gray Scale */
            --gray-light: #f1f4f2;
            --gray-medium: #6c757d;
            --gray-dark: #495057;
            --gray-border: #e9ecef;
            --gray-input: #ddd;
            
            /* Basic Colors */
            --white: #ffffff;
            --black: #000000;
            
            /* Status Colors */
            --error-bg: #f8d7da;
            --error-border: #f5c6cb;
            --error-text: #721c24;
            --success-bg: #d4edda;
            --success-border: #c3e6cb;
            --success-text: #155724;
            --warning-bg: #fff3cd;
            --warning-border: #ffeaa7;
            --warning-text: #856404;
            
            /* Overlay and UI Colors */
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --loading-overlay: rgba(0, 0, 0, 0.6);
            --spinner-bg: #f3f3f3;
            
            /* Hover States */
            --danger-hover: #d14a5a;
            --success-hover: #4a9f6b;
            --secondary-hover: #2d5a3d;
            
            /* Special Elements */
            --drop-border: #ccc;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            background: var(--light-color);
            min-height: 100vh;
            overflow: hidden;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .welcome-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .welcome-container {
            max-width: 800px;
            background: var(--white);
            border-radius: 16px;
            box-shadow: 0 20px 60px var(--shadow-color);
            overflow: hidden;
            margin: 20px;
        }

        .welcome-header {
            background: var(--secondary-color);
            color: var(--white);
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-selector select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }

        .language-selector select option {
            background: var(--white);
            color: var(--text-color);
        }

        .language-selector label {
            font-size: 14px;
            opacity: 0.9;
        }

        .welcome-header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .welcome-header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .welcome-header .small-print {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 8px;
            line-height: 1.3;
        }

        .welcome-header .small-print a {
            color: var(--white);
            transition: color 0.3s ease;
        }

        .welcome-content {
            padding: 30px;
        }

        .welcome-content > p {
            font-size: 1.1rem;
            color: var(--gray-medium);
            margin-bottom: 15px;
            text-align: center;
        }

        .file-drop-area {
            width: 100%;
            height: 280px;
            border: 3px dashed var(--drop-border);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            padding: 20px;
            transition: all 0.3s ease;
            background-color: var(--gray-light);
        }

        .file-drop-area.is-active {
            border-color: var(--confirm-color);
            background-color: rgba(64, 145, 108, 0.1);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--gray-medium);
            margin-bottom: 1rem;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-drop-area p {
            font-size: 1.1rem;
            color: var(--gray-dark);
            margin-bottom: 10px;
        }

        .file-drop-area .or-text {
            font-size: 0.9rem;
            color: var(--gray-medium);
            margin-bottom: 15px;
        }

        .upload-button {
            background: var(--confirm-color);
            color: var(--white);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-button:hover {
            background: var(--success-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(64, 145, 108, 0.3);
        }



        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--loading-overlay);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            flex-direction: column;
            color: var(--white);
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            border: 8px solid var(--spinner-bg);
            border-top: 8px solid var(--confirm-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loading-overlay p {
            font-size: 1.2rem;
            font-weight: 600;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        /* Remove focus outline from map container */
        #map:focus {
            outline: none;
        }

        .info-box {
            padding: 10px;
            background-color: var(--white);
            border-radius: 5px;
            max-width: 300px;
        }

        .info-title {
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .info-content {
            font-size: 14px;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .info-content a {
            color: var(--secondary-color);
            text-decoration: underline;
            transition: color 0.2s ease;
        }

        .info-content a:hover {
            color: var(--primary-color);
            text-decoration: underline;
        }

        .info-content a:visited {
            color: #2d6b4f;
        }

        .area-circle {
            stroke: #3388ff;
            stroke-width: 2;
            stroke-opacity: 0.8;
            fill: #3388ff;
            fill-opacity: 0.15;
        }

        /* Custom cluster styling to match app theme */
        .marker-cluster-small {
            background-color: rgba(52, 152, 219, 0.6);
            border: 2px solid #2980b9;
        }

        .marker-cluster-small div {
            background-color: rgba(52, 152, 219, 0.9);
            color: white;
            font-weight: 600;
        }

        .marker-cluster-medium {
            background-color: rgba(41, 128, 185, 0.6);
            border: 2px solid #2471a3;
        }

        .marker-cluster-medium div {
            background-color: rgba(41, 128, 185, 0.9);
            color: white;
            font-weight: 600;
        }

        .marker-cluster-large {
            background-color: rgba(30, 98, 145, 0.6);
            border: 2px solid #1b4f72;
        }

        .marker-cluster-large div {
            background-color: rgba(30, 98, 145, 0.9);
            color: white;
            font-weight: 600;
        }

        .year-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px var(--shadow-color);
            max-width: 280px;
        }

        .year-controls h3 {
            margin-bottom: 15px;
            color: var(--gray-dark);
            font-size: 1.1rem;
        }

        .year-controls h4 {
            margin-bottom: 10px;
            color: var(--gray-dark);
            font-size: 0.9rem;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group button {
            background: var(--gray-light);
            color: var(--gray-dark);
            border: 1px solid var(--gray-border);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-right: 8px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .control-group button:hover {
            background: var(--gray-border);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px var(--shadow-color);
        }

        .control-group button.active {
            background: var(--confirm-color);
            color: var(--white);
            border-color: var(--confirm-color);
        }

        .control-group button.active:hover {
            background: var(--success-hover);
            box-shadow: 0 2px 8px rgba(64, 145, 108, 0.3);
        }

        .legend {
            position: absolute;
            bottom: 30px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 4px 12px var(--shadow-color);
            max-width: 250px;
        }

        .legend h4 {
            margin-bottom: 10px;
            color: var(--gray-dark);
            font-size: 1.1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            min-width: 20px;
            min-height: 20px;
            margin-right: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .legend-color-gradient {
            width: 20px;
            height: 20px;
            min-width: 20px;
            min-height: 20px;
            margin-right: 10px;
            border-radius: 3px;
            background: linear-gradient(to right, #FFff00, #ff4800);
            flex-shrink: 0;
        }
        
        .legend-shortcuts {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 0.75rem;
            color: var(--gray);
            line-height: 1.4;
        }
        
        .legend-shortcuts strong {
            font-weight: 600;
        }

        #year-buttons button {
            padding: 6px 8px;
            margin: 2px;
            background-color: var(--gray-light);
            border: 1px solid var(--gray-border);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #year-buttons button:hover {
            background-color: var(--gray-border);
            transform: translateY(-1px);
        }

        #year-buttons button.active {
            background-color: var(--confirm-color);
            color: var(--white);
            border-color: var(--confirm-color);
        }

        .top-controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            box-shadow: 0 2px 8px var(--shadow-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .top-controls.hidden {
            display: none;
        }

        .top-control-btn {
            color: var(--white);
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            border-radius: 0;
            margin: 0;
        }

        .start-over-btn {
            background: #ff9800;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .start-over-btn:hover {
            background: #fb8c00;
            transform: translateY(-1px);
        }

        .controls-toggle-btn {
            background: var(--confirm-color);
        }

        .controls-toggle-btn:hover {
            background: var(--success-hover);
            transform: translateY(-1px);
        }

        .top-controls:hover {
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        /* Large screens */
        @media (min-width: 1200px) {
            .welcome-container {
                max-width: 900px;
            }
        }

        /* Medium screens */
        @media (max-width: 1024px) {
            .welcome-container {
                max-width: 700px;
                margin: 15px;
            }
            
            .welcome-header h1 {
                font-size: 2.2rem;
            }
        }

        /* Small screens */
        @media (max-width: 768px) {
            .welcome-header h1 {
                font-size: 2rem;
            }
            
            .welcome-container {
                margin: 10px;
            }
            
            .welcome-header,
            .welcome-content {
                padding: 20px;
            }

            .language-selector {
                position: static;
                justify-content: center;
                margin-bottom: 15px;
            }
            
            .file-drop-area {
                height: 200px;
                min-height: 44px;
            }
            
            .upload-button {
                min-height: 44px;
            }
            
            .year-controls {
                max-width: 200px;
                padding: 10px;
            }
            
            .legend {
                max-width: 200px;
                padding: 10px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .welcome-header h1 {
                font-size: 1.8rem;
            }
            
            .welcome-header,
            .welcome-content {
                padding: 15px;
            }
            
            .file-drop-area {
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Overlay -->
    <div id="welcomeOverlay" class="welcome-overlay">
        <div class="welcome-container">
            <div class="welcome-header">
                <div class="language-selector">                    
                    <label for="languageSelect" aria-label="Select language">üåê</label>
                    <select id="languageSelect" onchange="changeLanguage(this.value)">
                        <option value="en">English</option>
                        <option value="es">Espa√±ol</option>
                        <option value="fr">Fran√ßais</option>
                        <option value="pt">Portugu√™s</option>
                        <option value="sw">Swahili</option>
                        <option value="zh">‰∏≠Êñá</option>
                        <option value="th">‡πÑ‡∏ó‡∏¢</option>
                        <option value="am">·ä†·àõ·à≠·äõ</option>
                    </select>
                </div>
                <h1 data-i18n="title">GeoRoots Mapper</h1>
                <p data-i18n="subtitle">This is a simple tool for visual inspection of EU Deforestation Regulation DDS files.</p>
                <p data-i18n="privacyText" class="small-print">Your file and any of its content is only processed locally in your browser and none of your information is sent to GeoRoots, the map providers or anyone else.</p>
                <p data-i18n="licenseText" class="small-print">This software is free, released under GPLv3 open source license, see source code for full disclaimer.</p>
                <p class="small-print"><span data-i18n="downloadText">Download latest version and other tools on</span> <a href="https://georoots.eu/">https://georoots.eu/</a></p>
            </div>
            <div class="welcome-content">
                <div id="fileDropArea" class="file-drop-area">
                    <div class="upload-icon">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                            <path d="M12,12L16,16H13.5V19H10.5V16H8L12,12Z"/>
                        </svg>
                    </div>
                    <p data-i18n="uploadText">Drag & drop your GeoJSON file here</p>
                    <p class="or-text" data-i18n="orText">or</p>
                    <input type="file" id="fileInput" class="hidden" accept=".geojson,.json">
                    <button id="fileSelectButton" class="upload-button" data-i18n="selectGeoJSONButton">Select GeoJSON File</button>
                </div>
            </div>

        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <p data-i18n="processingText">Processing GeoJSON data...</p>
    </div>

    <!-- Top Control Buttons -->
    <div id="topControls" class="top-controls hidden">
        <button id="startOverButton" class="top-control-btn start-over-btn" data-i18n="startOver">Start Over</button>
        <button id="controlsToggle" class="top-control-btn controls-toggle-btn" data-i18n="hideControls">Hide Controls</button>
    </div>

    <!-- Tree Loss Controls -->
    <div id="deforestationControls" class="year-controls hidden">
        <h3 data-i18n="deforestationControlsTitle">Tree Loss Controls</h3>
        <div class="control-group">
            <h4 data-i18n="timePeriods">Time Periods:</h4>
            <button id="btn-all-years" data-i18n="allYears">All Years</button>
            <button id="btn-before-2021" data-i18n="before2021">Before 2021</button>
            <button id="btn-2021-onwards" class="active" data-i18n="from2021">2021 Onwards</button>
            <button id="btn-clear-all" data-i18n="clearAll">Clear All</button>
            <button id="btn-custom" data-i18n="custom">Custom</button>
        </div>
        <div id="individualYearsSection" class="control-group hidden">
            <h4 data-i18n="individualYears">Individual Years:</h4>
            <div id="year-buttons"></div>
        </div>
    </div>

    <!-- Legend -->
    <div id="mapLegend" class="legend hidden">
        <h4 data-i18n="legendTitle">Legend</h4>
        <div id="legend-items"></div>
        <div class="legend-shortcuts">
            <strong data-i18n="keyboardShortcuts">Keyboard Shortcuts</strong><br>
            <span data-i18n="shortcutSpace">Space: Tree Loss Overlay</span><br>
            <span data-i18n="shortcutF">F: Tree Cover Overlay</span><br>
            <span data-i18n="shortcutT">T: Satellite 2020 & Now</span>
        </div>
    </div>

    <!-- Map Container -->
    <div id="map" tabindex="0"></div>

    <!-- Translation Data -->
    <script type="application/json" id="lang-en">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - Tree Loss Visualization",
        "downloadText": "Download latest version and other tools on",
        "subtitle": "This is a simple tool for visual inspection of EU Deforestation Regulation DDS files.",
        "uploadInfo": "Your provided GeoJSON file will be displayed on a map together with tree loss overlay.",
        "uploadText": "Drag & drop your GeoJSON file here",
        "orText": "or",
        "selectGeoJSONButton": "Select GeoJSON File",
        "privacyText": "Your file and any of its content is only processed locally in your browser and none of your information is sent to GeoRoots, the map providers or anyone else.",
        "licenseText": "This software is free, released under GPLv3 open source license, see source code for full disclaimer.",
        "processingText": "Processing GeoJSON data...",
        "startOver": "Start Over",
        "hideControls": "Hide Controls",
        "showControls": "Show Controls",
        "deforestationControlsTitle": "Tree Loss Controls",
        "timePeriods": "Time Periods:",
        "allYears": "All Years",
        "before2021": "Before 2021",
        "from2021": "2021 Onwards",
        "clearAll": "Clear All",
        "custom": "Custom",
        "individualYears": "Individual Years:",
        "legendTitle": "Legend",
        "plotBoundary": "Plot Boundary",
        "treeCoverLoss": "{year} Tree Cover Loss",
        "treeCoverLoss2001_2020": "Tree Cover Loss 2001-2020",
        "treeCoverLoss2021_2024": "Tree Cover Loss 2021-2024 (EUDR)",
        "noProperties": "No properties found",
        "propertiesTitle": "Properties",
        "invalidGeoJSON": "Error processing the file. Please make sure it is a valid GeoJSON file.",
        "streetMap": "Street Map",
        "topoMap": "Topographic Map",
        "satelliteLatest": "Satellite latest",
        "satellite2020": "Satellite from 2020",
        "forestCoverage": "Forest Coverage (GFC 2020v3)",
        "treeCoverLossAttribution": "Tree Cover Loss ¬© Global Forest Watch",
        "esri2020Attribution": "Tiles ¬© Esri 2020 ‚Äî Source: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "European Commission JRC - Global Forest Change 2020v3",
        "keyboardShortcuts": "Keyboard Shortcuts",
        "shortcutSpace": "Space: Tree Loss Overlay",
        "shortcutF": "F: Tree Cover Overlay",
        "shortcutT": "T: Satellite 2020 & Now"
    }
    </script>

    <script type="application/json" id="lang-es">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - Visualizaci√≥n de P√©rdida de √Årboles",
        "downloadText": "Descarga la versi√≥n m√°s reciente y otras herramientas en",
        "subtitle": "Esta es una herramienta simple para la inspecci√≥n visual de archivos DDS del Reglamento de Deforestaci√≥n de la UE.",
        "uploadInfo": "Tu archivo GeoJSON se mostrar√° en un mapa junto con la superposici√≥n de p√©rdida de √°rboles.",
        "uploadText": "Arrastra y suelta tu archivo GeoJSON aqu√≠",
        "orText": "o",
        "selectGeoJSONButton": "Seleccionar archivo GeoJSON",
        "privacyText": "Tu archivo y su contenido solo se procesan localmente en tu navegador y ninguna informaci√≥n se env√≠a a GeoRoots, los proveedores de mapas ni a nadie m√°s.",
        "licenseText": "Este software es gratuito, bajo licencia de c√≥digo abierto GPLv3; consulta el c√≥digo fuente para el descargo de responsabilidad completo.",
        "processingText": "Procesando datos GeoJSON...",
        "startOver": "Empezar de nuevo",
        "hideControls": "Ocultar controles",
        "showControls": "Mostrar controles",
        "deforestationControlsTitle": "Controles de P√©rdida de √Årboles",
        "timePeriods": "Per√≠odos de tiempo:",
        "allYears": "Todos los a√±os",
        "before2021": "Antes de 2021",
        "from2021": "Desde 2021",
        "clearAll": "Limpiar todo",
        "custom": "Personalizado",
        "individualYears": "A√±os individuales:",
        "legendTitle": "Leyenda",
        "plotBoundary": "L√≠mite de parcela",
        "treeCoverLoss": "P√©rdida de cobertura arb√≥rea {year}",
        "treeCoverLoss2001_2020": "P√©rdida de cobertura arb√≥rea 2001-2020",
        "treeCoverLoss2021_2024": "P√©rdida de cobertura arb√≥rea 2021-2024 (EUDR)",
        "noProperties": "No se encontraron propiedades",
        "propertiesTitle": "Propiedades",
        "invalidGeoJSON": "Error al procesar el archivo. Por favor, aseg√∫rate de que es un archivo GeoJSON v√°lido.",
        "streetMap": "Mapa de calles",
        "topoMap": "Mapa topogr√°fico",
        "satelliteLatest": "Sat√©lite m√°s reciente",
        "satellite2020": "Sat√©lite de 2020",
        "forestCoverage": "Cobertura forestal (GFC 2020v3)",
        "treeCoverLossAttribution": "P√©rdida de cobertura arb√≥rea ¬© Global Forest Watch",
        "esri2020Attribution": "Teselas ¬© Esri 2020 ‚Äî Fuente: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Comisi√≥n Europea JRC - Cambio Global de Bosques 2020v3",
        "keyboardShortcuts": "Atajos de Teclado",
        "shortcutSpace": "Espacio: Superposici√≥n de P√©rdida",
        "shortcutF": "F: Superposici√≥n de Cobertura",
        "shortcutT": "T: Sat√©lite 2020 y Actual"
    }
    </script>

    <script type="application/json" id="lang-fr">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - Visualisation de la perte d'arbres",
        "downloadText": "T√©l√©chargez la derni√®re version et d'autres outils sur",
        "subtitle": "Ceci est un outil simple pour l'inspection visuelle des fichiers DDS du r√®glement europ√©en sur la d√©forestation.",
        "uploadInfo": "Votre fichier GeoJSON sera affich√© sur une carte avec la superposition de la perte d'arbres.",
        "uploadText": "Glissez-d√©posez votre fichier GeoJSON ici",
        "orText": "ou",
        "selectGeoJSONButton": "S√©lectionner un fichier GeoJSON",
        "privacyText": "Votre fichier et son contenu ne sont trait√©s que localement dans votre navigateur et aucune information n'est envoy√©e √† GeoRoots, aux fournisseurs de cartes ou √† quiconque.",
        "licenseText": "Ce logiciel est gratuit, publi√© sous licence open source GPLv3, voir le code source pour la clause de non-responsabilit√© compl√®te.",
        "processingText": "Traitement des donn√©es GeoJSON...",
        "startOver": "Recommencer",
        "hideControls": "Masquer les contr√¥les",
        "showControls": "Afficher les contr√¥les",
        "deforestationControlsTitle": "Contr√¥les de la perte d'arbres",
        "timePeriods": "P√©riodes de temps :",
        "allYears": "Toutes les ann√©es",
        "before2021": "Avant 2021",
        "from2021": "Depuis 2021",
        "clearAll": "Tout effacer",
        "custom": "Personnalis√©",
        "individualYears": "Ann√©es individuelles :",
        "legendTitle": "L√©gende",
        "plotBoundary": "Limite de la parcelle",
        "treeCoverLoss": "Perte de couvert arbor√© {year}",
        "treeCoverLoss2001_2020": "Perte de couvert arbor√© 2001-2020",
        "treeCoverLoss2021_2024": "Perte de couvert arbor√© 2021-2024 (EUDR)",
        "noProperties": "Aucune propri√©t√© trouv√©e",
        "propertiesTitle": "Propri√©t√©s",
        "invalidGeoJSON": "Erreur lors du traitement du fichier. Veuillez vous assurer qu'il s'agit d'un fichier GeoJSON valide.",
        "streetMap": "Carte des rues",
        "topoMap": "Carte topographique",
        "satelliteLatest": "Satellite le plus r√©cent",
        "satellite2020": "Satellite de 2020",
        "forestCoverage": "Couverture foresti√®re (GFC 2020v3)",
        "treeCoverLossAttribution": "Perte de couvert arbor√© ¬© Global Forest Watch",
        "esri2020Attribution": "Tuiles ¬© Esri 2020 ‚Äî Source : Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Commission europ√©enne JRC - Changement global des for√™ts 2020v3",
        "keyboardShortcuts": "Raccourcis Clavier",
        "shortcutSpace": "Espace : Superposition de Perte",
        "shortcutF": "F : Superposition de Couverture",
        "shortcutT": "T : Satellite 2020 et Actuel"
    }
    </script>

    <script type="application/json" id="lang-pt">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - Visualiza√ß√£o de Perda de √Årvores",
        "downloadText": "Baixe a vers√£o mais recente e outras ferramentas em",
        "subtitle": "Esta √© uma ferramenta simples para inspe√ß√£o visual de arquivos DDS do Regulamento de Desmatamento da UE.",
        "uploadInfo": "Seu arquivo GeoJSON ser√° exibido em um mapa junto com a sobreposi√ß√£o de perda de √°rvores.",
        "uploadText": "Arraste e solte seu arquivo GeoJSON aqui",
        "orText": "ou",
        "selectGeoJSONButton": "Selecionar arquivo GeoJSON",
        "privacyText": "Seu arquivo e qualquer conte√∫do dele s√£o processados apenas localmente no seu navegador e nenhuma informa√ß√£o √© enviada ao GeoRoots, aos provedores de mapas ou a qualquer outra pessoa.",
        "licenseText": "Este software √© gratuito, licenciado sob GPLv3 de c√≥digo aberto; veja o c√≥digo‚Äëfonte para o aviso legal completo.",
        "processingText": "Processando dados GeoJSON...",
        "startOver": "Recome√ßar",
        "hideControls": "Ocultar controles",
        "showControls": "Mostrar controles",
        "deforestationControlsTitle": "Controles de Perda de √Årvores",
        "timePeriods": "Per√≠odos de tempo:",
        "allYears": "Todos os anos",
        "before2021": "Antes de 2021",
        "from2021": "A partir de 2021",
        "clearAll": "Limpar tudo",
        "custom": "Personalizado",
        "individualYears": "Anos individuais:",
        "legendTitle": "Legenda",
        "plotBoundary": "Limite da parcela",
        "treeCoverLoss": "Perda de cobertura arb√≥rea {year}",
        "treeCoverLoss2001_2020": "Perda de cobertura arb√≥rea 2001-2020",
        "treeCoverLoss2021_2024": "Perda de cobertura arb√≥rea 2021-2024 (EUDR)",
        "noProperties": "Nenhuma propriedade encontrada",
        "propertiesTitle": "Propriedades",
        "invalidGeoJSON": "Erro ao processar o arquivo. Certifique-se de que √© um arquivo GeoJSON v√°lido.",
        "streetMap": "Mapa de ruas",
        "topoMap": "Mapa topogr√°fico",
        "satelliteLatest": "Sat√©lite mais recente",
        "satellite2020": "Sat√©lite de 2020",
        "forestCoverage": "Cobertura florestal (GFC 2020v3)",
        "treeCoverLossAttribution": "Perda de cobertura arb√≥rea ¬© Global Forest Watch",
        "esri2020Attribution": "Blocos ¬© Esri 2020 ‚Äî Fonte: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Comiss√£o Europeia JRC - Mudan√ßa Global das Florestas 2020v3",
        "keyboardShortcuts": "Atalhos de Teclado",
        "shortcutSpace": "Espa√ßo: Sobreposi√ß√£o de Perda",
        "shortcutF": "F: Sobreposi√ß√£o de Cobertura",
        "shortcutT": "T: Sat√©lite 2020 e Atual"
    }
    </script>

    <script type="application/json" id="lang-sw">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - Taswira ya Upotevu wa Miti",
        "downloadText": "Pakua toleo la hivi karibuni na zana nyingine katika",
        "subtitle": "Hii ni zana rahisi kwa ukaguzi wa macho wa faili za DDS za Udhibiti wa Ukataji Miti wa EU.",
        "uploadInfo": "Faili yako ya GeoJSON itaonyeshwa kwenye ramani pamoja na tabaka la upotevu wa miti.",
        "uploadText": "Buruta na udondoshe faili lako la GeoJSON hapa",
        "orText": "au",
        "selectGeoJSONButton": "Chagua Faili ya GeoJSON",
        "privacyText": "Faili lako na maudhui yake yote yanachakatwa tu ndani ya kivinjari chako na hakuna taarifa zako zinazotumwa kwa GeoRoots, watoa ramani au mtu mwingine yeyote.",
        "licenseText": "Programu hii ni bure, chini ya leseni ya vyanzo wazi GPLv3; angalia msimbo chanzo kwa taarifa kamili.",
        "processingText": "Inachakata data ya GeoJSON...",
        "startOver": "Anza upya",
        "hideControls": "Ficha vidhibiti",
        "showControls": "Onyesha vidhibiti",
        "deforestationControlsTitle": "Vidhibiti vya Upotevu wa Miti",
        "timePeriods": "Vipindi vya muda:",
        "allYears": "Miaka yote",
        "before2021": "Kabla ya 2021",
        "from2021": "Kuanzia 2021",
        "clearAll": "Futa vyote",
        "custom": "Maalum",
        "individualYears": "Miaka ya kibinafsi:",
        "legendTitle": "Maelezo",
        "plotBoundary": "Mpaka wa shamba",
        "treeCoverLoss": "Upotevu wa miti {year}",
        "treeCoverLoss2001_2020": "Upotevu wa miti 2001-2020",
        "treeCoverLoss2021_2024": "Upotevu wa miti 2021-2024 (EUDR)",
        "noProperties": "Hakuna mali zilizopatikana",
        "propertiesTitle": "Mali",
        "invalidGeoJSON": "Hitilafu katika kuchakata faili. Tafadhali hakikisha ni faili halali ya GeoJSON.",
        "streetMap": "Ramani ya mitaa",
        "topoMap": "Ramani ya topografia",
        "satelliteLatest": "Satilaiti ya hivi karibuni",
        "satellite2020": "Satilaiti ya 2020",
        "forestCoverage": "Ufunikaji wa misitu (GFC 2020v3)",
        "treeCoverLossAttribution": "Upotevu wa miti ¬© Global Forest Watch",
        "esri2020Attribution": "Vigae ¬© Esri 2020 ‚Äî Chanzo: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Tume ya Ulaya JRC - Mabadiliko ya Misitu Duniani 2020v3",
        "keyboardShortcuts": "Njia za Mkato",
        "shortcutSpace": "Nafasi: Tabaka la Upotevu",
        "shortcutF": "F: Tabaka la Ufunikaji",
        "shortcutT": "T: Satilaiti 2020 na Sasa"
    }
    </script>

    <script type="application/json" id="lang-zh">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - Ê†ëÊú®ÊçüÂ§±ÂèØËßÜÂåñ",
        "downloadText": "Âú®Ê≠§‰∏ãËΩΩÊúÄÊñ∞ÁâàÊú¨ÂèäÂÖ∂ÂÆÉÂ∑•ÂÖ∑",
        "subtitle": "ËøôÊòØ‰∏Ä‰∏™Áî®‰∫éÂèØËßÜÂåñÊ£ÄÊü•Ê¨ßÁõüÊ£ÆÊûóÁ†ç‰ºêÊ≥ïËßÑ DDS Êñá‰ª∂ÁöÑÁÆÄÂçïÂ∑•ÂÖ∑„ÄÇ",
        "uploadInfo": "ÊÇ®Êèê‰æõÁöÑ GeoJSON Êñá‰ª∂Â∞Ü‰∏éÊ†ëÊú®ÊçüÂ§±Âè†Âä†Â±Ç‰∏ÄËµ∑ÊòæÁ§∫Âú®Âú∞Âõæ‰∏ä„ÄÇ",
        "uploadText": "Â∞ÜÊÇ®ÁöÑ GeoJSON Êñá‰ª∂ÊãñÊîæÂà∞Ê≠§Â§Ñ",
        "orText": "Êàñ",
        "selectGeoJSONButton": "ÈÄâÊã© GeoJSON Êñá‰ª∂",
        "privacyText": "ÊÇ®ÁöÑÊñá‰ª∂ÂèäÂÖ∂ÂÜÖÂÆπ‰ªÖÂú®ÊÇ®ÁöÑÊµèËßàÂô®‰∏≠Êú¨Âú∞Â§ÑÁêÜÔºåÊÇ®ÁöÑ‰ø°ÊÅØ‰∏ç‰ºöÂèëÈÄÅÁªô GeoRoots„ÄÅÂú∞ÂõæÊèê‰æõÂïÜÊàñ‰ªª‰ΩïÂÖ∂‰ªñ‰∫∫„ÄÇ",
        "licenseText": "Êú¨ËΩØ‰ª∂ÂÖçË¥πÔºåÈááÁî® GPLv3 ÂºÄÊ∫êËÆ∏ÂèØÔºåËØ¶ËßÅÊ∫ê‰ª£Á†ÅÂÖçË¥£Â£∞Êòé„ÄÇ",
        "processingText": "Ê≠£Âú®Â§ÑÁêÜ GeoJSON Êï∞ÊçÆ...",
        "startOver": "ÈáçÊñ∞ÂºÄÂßã",
        "hideControls": "ÈöêËóèÊéß‰ª∂",
        "showControls": "ÊòæÁ§∫Êéß‰ª∂",
        "deforestationControlsTitle": "Ê†ëÊú®ÊçüÂ§±ÊéßÂà∂",
        "timePeriods": "Êó∂Èó¥ÊÆµÔºö",
        "allYears": "ÊâÄÊúâÂπ¥‰ªΩ",
        "before2021": "2021 Âπ¥‰πãÂâç",
        "from2021": "2021 Âπ¥Âèä‰ª•Âêé",
        "clearAll": "Ê∏ÖÈô§ÂÖ®ÈÉ®",
        "custom": "Ëá™ÂÆö‰πâ",
        "individualYears": "ÂçïÁã¨Âπ¥‰ªΩÔºö",
        "legendTitle": "Âõæ‰æã",
        "plotBoundary": "Âú∞ÂùóËæπÁïå",
        "treeCoverLoss": "{year} Âπ¥Ê£ÆÊûóÊçüÂ§±",
        "treeCoverLoss2001_2020": "Ê£ÆÊûóÊçüÂ§± 2001-2020",
        "treeCoverLoss2021_2024": "Ê£ÆÊûóÊçüÂ§± 2021-2024 (EUDR)",
        "noProperties": "Êú™ÊâæÂà∞Â±ûÊÄß",
        "propertiesTitle": "Â±ûÊÄß",
        "invalidGeoJSON": "Â§ÑÁêÜÊñá‰ª∂Âá∫Èîô„ÄÇËØ∑Á°Æ‰øùÂÆÉÊòØÊúâÊïàÁöÑ GeoJSON Êñá‰ª∂„ÄÇ",
        "streetMap": "Ë°óÈÅìÂú∞Âõæ",
        "topoMap": "Âú∞ÂΩ¢Âõæ",
        "satelliteLatest": "ÊúÄÊñ∞Âç´ÊòüÂõæ",
        "satellite2020": "2020 Âπ¥Âç´ÊòüÂõæ",
        "forestCoverage": "Ê£ÆÊûóË¶ÜÁõñÔºàGFC 2020v3Ôºâ",
        "treeCoverLossAttribution": "Ê£ÆÊûóÊçüÂ§± ¬© Global Forest Watch",
        "esri2020Attribution": "Áì¶Áâá ¬© Esri 2020 ‚Äî Êù•Ê∫êÔºöEsri, Maxar, Earthstar Geographics",
        "gfcAttribution": "Ê¨ßÁõüÂßîÂëò‰ºö JRC - ÂÖ®ÁêÉÊ£ÆÊûóÂèòÂåñ 2020v3",
        "keyboardShortcuts": "ÈîÆÁõòÂø´Êç∑ÈîÆ",
        "shortcutSpace": "Á©∫Ê†ºÔºöÊ†ëÊú®ÊçüÂ§±Âè†Âä†Â±Ç",
        "shortcutF": "FÔºöÊ†ëÊú®Ë¶ÜÁõñÂè†Âä†Â±Ç",
        "shortcutT": "TÔºöÂç´Êòü 2020 ÂíåÁé∞Âú®"
    }
    </script>

    <script type="application/json" id="lang-th">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏†‡∏≤‡∏û‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ",
        "downloadText": "‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏≠‡∏∑‡πà‡∏ô ‡πÜ ‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà",
        "subtitle": "‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå DDS ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡πÑ‡∏°‡πâ‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏õ‡πà‡∏≤‡∏Ç‡∏≠‡∏á‡∏™‡∏´‡∏†‡∏≤‡∏û‡∏¢‡∏∏‡πÇ‡∏£‡∏õ",
        "uploadInfo": "‡πÑ‡∏ü‡∏•‡πå GeoJSON ‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏´‡πâ‡∏°‡∏≤‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ",
        "uploadText": "‡∏•‡∏≤‡∏Å‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå GeoJSON ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà",
        "orText": "‡∏´‡∏£‡∏∑‡∏≠",
        "selectGeoJSONButton": "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå GeoJSON",
        "privacyText": "‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡∏∞‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏î ‡πÜ ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á GeoRoots ‡∏ú‡∏π‡πâ‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ‡∏´‡∏£‡∏∑‡∏≠‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•‡∏≠‡∏∑‡πà‡∏ô",
        "licenseText": "‡∏ã‡∏≠‡∏ü‡∏ï‡πå‡πÅ‡∏ß‡∏£‡πå‡∏ô‡∏µ‡πâ‡∏ü‡∏£‡∏µ ‡∏†‡∏≤‡∏¢‡πÉ‡∏ï‡πâ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏õ‡∏¥‡∏î GPLv3 ‡∏î‡∏π‡∏ã‡∏≠‡∏£‡πå‡∏™‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏ö‡∏ú‡∏¥‡∏î‡∏â‡∏ö‡∏±‡∏ö‡πÄ‡∏ï‡πá‡∏°",
        "processingText": "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON...",
        "startOver": "‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà",
        "hideControls": "‡∏ã‡πà‡∏≠‡∏ô‡∏ï‡∏±‡∏ß‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°",
        "showControls": "‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏±‡∏ß‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°",
        "deforestationControlsTitle": "‡∏ï‡∏±‡∏ß‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ",
        "timePeriods": "‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤:",
        "allYears": "‡∏ó‡∏∏‡∏Å‡∏õ‡∏µ",
        "before2021": "‡∏Å‡πà‡∏≠‡∏ô 2021",
        "from2021": "‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà 2021",
        "clearAll": "‡∏•‡πâ‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
        "custom": "‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á",
        "individualYears": "‡∏õ‡∏µ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏µ:",
        "legendTitle": "‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢",
        "plotBoundary": "‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡πÅ‡∏õ‡∏•‡∏á",
        "treeCoverLoss": "‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏Å‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ {year}",
        "treeCoverLoss2001_2020": "‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏Å‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ 2001-2020",
        "treeCoverLoss2021_2024": "‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏Å‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ 2021-2024 (EUDR)",
        "noProperties": "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥",
        "propertiesTitle": "‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥",
        "invalidGeoJSON": "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå GeoJSON ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á",
        "streetMap": "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏ô‡∏ô",
        "topoMap": "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏†‡∏π‡∏°‡∏¥‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®",
        "satelliteLatest": "‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î",
        "satellite2020": "‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏°‡∏à‡∏≤‡∏Å‡∏õ‡∏µ 2020",
        "forestCoverage": "‡∏Å‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏õ‡πà‡∏≤ (GFC 2020v3)",
        "treeCoverLossAttribution": "‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡∏Å‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ ¬© Global Forest Watch",
        "esri2020Attribution": "‡πÑ‡∏ó‡∏•‡πå ¬© Esri 2020 ‚Äî ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "‡∏Ñ‡∏ì‡∏∞‡∏Å‡∏£‡∏£‡∏°‡∏≤‡∏ò‡∏¥‡∏Å‡∏≤‡∏£‡∏¢‡∏∏‡πÇ‡∏£‡∏õ JRC - ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏õ‡πà‡∏≤‡πÑ‡∏ú‡πà‡∏ó‡∏±‡πà‡∏ß‡πÇ‡∏•‡∏Å 2020v3",
        "keyboardShortcuts": "‡∏ó‡∏≤‡∏á‡∏•‡∏±‡∏î‡πÅ‡∏õ‡πâ‡∏ô‡∏û‡∏¥‡∏°‡∏û‡πå",
        "shortcutSpace": "Space: ‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≠‡∏ô‡∏ó‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢",
        "shortcutF": "F: ‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≠‡∏ô‡∏ó‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°",
        "shortcutT": "T: ‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏° 2020 ‡πÅ‡∏•‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"
    }
    </script>

    <script type="application/json" id="lang-am">
    {
        "title": "GeoRoots Mapper",
        "pageTitle": "GeoRoots Mapper - ·ã®·ãõ·çé·âΩ ·ä™·à≥·à´ ·àõ·à≥·ã´",
        "downloadText": "·ã®·âÖ·à≠·â• ·àµ·à™·âµ·äï ·ä•·äì ·àå·àé·âΩ ·àò·à≥·à™·ã´·ãé·âΩ·äï ·ã´·ãç·à≠·ã±",
        "subtitle": "·ã≠·àÖ ·âÄ·àã·àç ·àò·à≥·à™·ã´ ·äê·ãç ·àà·ä†·ãç·àÆ·çì ·àÖ·â•·à®·âµ ·ã®·ã∞·äï ·àõ·å•·çã·âµ ·ã∞·äï·â• DDS ·çã·ã≠·àé·âΩ ·àà·àõ·ã®·âµ·ç¢",
        "uploadInfo": "·ã®·âÄ·à®·â†·ãç GeoJSON ·çã·ã≠·àç ·â†·ä´·à≠·â≥ ·àã·ã≠ ·ä®·ãõ·çé·âΩ ·ä™·à≥·à´ ·ä†·ä´·â£·â¢ ·åã·à≠ ·ã≠·â≥·ã´·àç·ç¢",
        "uploadText": "·ã®GeoJSON ·çã·ã≠·àç·ãé·äï ·ä•·ãö·àÖ ·ã≠·åé·âµ·â± ·ä•·äì ·ã≠·å®·àù·à©",
        "orText": "·ãà·ã≠·àù",
        "selectGeoJSONButton": "GeoJSON ·çã·ã≠·àç ·ã≠·àù·à®·å°",
        "privacyText": "·çã·ã≠·àâ ·ä•·äì ·ãç·àÇ·â° ·â†·ä†·äï·â∞ ·ä†·à≥·àΩ ·â•·âª ·ã≠·à∞·à´·àç·ç£ ·àò·à®·åÉ·ãé ·ãà·ã∞ GeoRoots ·ãà·ã≠·àù ·àõ·äï·äõ·ãç·àù ·à∞·ãç ·ä†·ã≠·àã·ä®·ãç·àù·ç¢",
        "licenseText": "·ã≠·àÖ ·à∂·çç·âµ·ãå·à≠ ·äê·çÉ ·äê·ãç·ç£ ·â† GPLv3 ·ä≠·çç·âµ ·àù·äï·å≠ ·çà·âÉ·ãµ ·ã®·â∞·à∞·å†·ç£ ·àô·àâ ·àõ·àµ·â∞·äì·åà·ãµ ·àà·àõ·ã®·âµ ·ã®·àù·äï·å≠ ·äÆ·ãµ·äï ·ã≠·àò·àç·ä®·â±·ç¢",
        "processingText": "GeoJSON ·ã≥·â≥·äï ·â†·àõ·àµ·â∞·äì·åà·ãµ ·àã·ã≠...",
        "startOver": "·ä•·äï·ã∞·åà·äì ·åÄ·àù·à≠",
        "hideControls": "·àò·âÜ·å£·å†·à™·ã´·ãé·âπ·äï ·ã∞·â•·âÖ",
        "showControls": "·àò·âÜ·å£·å†·à™·ã´·ãé·âπ·äï ·ä†·à≥·ã≠",
        "deforestationControlsTitle": "·ã®·ãõ·çé·âΩ ·ä™·à≥·à´ ·àò·âÜ·å£·å†·à™·ã´·ãé·âΩ",
        "timePeriods": "·ã®·åä·ãú ·åä·ãú·ãé·âΩ:",
        "allYears": "·àÅ·àâ·àù ·ãì·àò·â≥·âµ",
        "before2021": "·ä®2021 ·â†·çä·âµ",
        "from2021": "2021 ·åÄ·àù·àÆ",
        "clearAll": "·àÅ·àâ·äï·àù ·ä†·å•·çã",
        "custom": "·â•·åÅ",
        "individualYears": "·ã®·â∞·äì·å†·àâ ·ãì·àò·â≥·âµ:",
        "legendTitle": "·àò·àà·ä™·ã´",
        "plotBoundary": "·ã®·â¶·â≥ ·ãµ·äï·â†·à≠",
        "treeCoverLoss": "·ã®·ã∞·äï ·àò·ä®·àã·ä®·ã´ ·å•·çã·âµ {year}",
        "treeCoverLoss2001_2020": "·ã®·ã∞·äï ·àò·ä®·àã·ä®·ã´ ·å•·çã·âµ 2001-2020",
        "treeCoverLoss2021_2024": "·ã®·ã∞·äï ·àò·ä®·àã·ä®·ã´ ·å•·çã·âµ 2021-2024 (EUDR)",
        "noProperties": "·àù·äï·àù ·â£·àÖ·à™·ã´·âµ ·ä†·àç·â∞·åà·äô·àù",
        "propertiesTitle": "·â£·àÖ·à™·ã´·âµ",
        "invalidGeoJSON": "·çã·ã≠·àâ·äï ·àõ·àµ·â∞·äì·åà·ãµ ·àã·ã≠ ·àµ·àÖ·â∞·âµ·ç¢ ·ä•·â£·ä≠·ãé ·âµ·ä≠·ä≠·àà·äõ GeoJSON ·çã·ã≠·àç ·àò·àÜ·äë·äï ·ã´·à®·åã·åç·å°·ç¢",
        "streetMap": "·ã®·àò·äï·åà·ãµ ·ä´·à≠·â≥",
        "topoMap": "·ã®·ä®·â∞·àõ ·ä´·à≠·â≥",
        "satelliteLatest": "·ã®·âÖ·à≠·â• ·åä·ãú ·à≥·â∞·àã·ã≠·âµ",
        "satellite2020": "·ã®2020 ·à≥·â∞·àã·ã≠·âµ",
        "forestCoverage": "·ã®·ã±·à≠ ·àΩ·çã·äï (GFC 2020v3)",
        "treeCoverLossAttribution": "·ã®·ã∞·äï ·àò·ä®·àã·ä®·ã´ ·å•·çã·âµ ¬© Global Forest Watch",
        "esri2020Attribution": "·â≥·ã≠·àç ¬© Esri 2020 ‚Äî ·àù·äï·å≠: Esri, Maxar, Earthstar Geographics",
        "gfcAttribution": "·ã®·ä†·ãç·àÆ·çì ·äÆ·àö·àΩ·äï JRC - ·ã®·ã±·à≠ ·ãì·àà·àù ·àà·ãç·å• 2020v3",
        "keyboardShortcuts": "·ã®·âÅ·àç·çç ·à∞·àå·ã≥ ·ä†·âã·à´·åÆ·âΩ",
        "shortcutSpace": "·ä≠·çç·â∞·âµ: ·ã®·ãõ·çç ·ä™·à≥·à´ ·äï·â•·à≠·â•·à≠",
        "shortcutF": "F: ·ã®·ãõ·çç ·àΩ·çã·äï ·äï·â•·à≠·â•·à≠",
        "shortcutT": "T: ·à≥·â∞·àã·ã≠·âµ 2020 ·ä•·äì ·ä†·àÅ·äï"
    }
    </script>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script>
        // Global variables
        let map;
        let polygonLayer;
        let pointLayer;
        let pointMarkerLayer;
        let polygonMarkerLayer;
        let pointClusterGroup;
        let polygonClusterGroup;
        let currentGeoJSON;
        let treeLossLayer;
        let forestCoverageLayer;
        let baseLayers = {};
        let layerControl;
        let activeYears = {};
        let currentBaseLayer;
        let satelliteTooltip;
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            initializeTranslations();
            const savedLanguage = localStorage.getItem('georoots-mapper-language');
            const browserLanguage = navigator.language.split('-')[0];
            const defaultLanguage = savedLanguage || (translations[browserLanguage] ? browserLanguage : 'en');
            document.getElementById('languageSelect').value = defaultLanguage;
            changeLanguage(defaultLanguage);
            showWelcomeOverlay();
            initializeFileUpload();
        }

        function showWelcomeOverlay() {
            document.getElementById('welcomeOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        
        function hideWelcomeOverlay() {
            document.getElementById('welcomeOverlay').style.display = 'none';
        }

        function getBaseLayers() {
            return {
                [getText('streetMap')]: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }),
                [getText('topoMap')]: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    maxNativeZoom: 15,
                    attribution: '&copy; <a href="https://opentopomap.org">OpenTopoMap</a> contributors'
                }),
                [getText('satelliteLatest')]: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    maxZoom: 19,
                    maxNativeZoom: 18,
                    attribution: '&copy; <a href="https://www.esri.com">Esri</a>'
                }),
                [getText('satellite2020')]: L.tileLayer('https://wayback-b.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer/tile/29260/{z}/{y}/{x}', {
                    attribution: getText('esri2020Attribution'),
                    maxZoom: 19,
                    maxNativeZoom: 17,
                    tileSize: 256
                })
            };
        }
        function getOverlayMaps() {
            // Create forest coverage layer only once and reuse it
            if (!forestCoverageLayer) {
                forestCoverageLayer = L.tileLayer.wms('https://forest-observatory.ec.europa.eu/wms/RMAP', {
                    layers: 'cover_v3',
                    format: 'image/png',
                    transparent: true,
                    version: '1.3.0',
                    attribution: getText('gfcAttribution'),
                    maxZoom: 19
                });
            }
            
            return {
                [getText('forestCoverage')]: forestCoverageLayer
            };
        }

        function initializeMap() {
            map = L.map('map', {
                center: [0, 0],
                zoom: 2,
                zoomControl: true,
                maxZoom: 19
            });
            baseLayers = getBaseLayers();
            // Add the first base layer to the map
            const firstBaseLayer = Object.values(baseLayers)[0];
            firstBaseLayer.addTo(map);
            currentBaseLayer = firstBaseLayer;
            polygonLayer = L.layerGroup().addTo(map);
            pointLayer = L.layerGroup().addTo(map);
            pointMarkerLayer = L.layerGroup().addTo(map);
            polygonMarkerLayer = L.layerGroup().addTo(map);
            
            // Initialize cluster groups for performance with large datasets
            pointClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 80,
                spiderfyOnMaxZoom: false,
                showCoverageOnHover: false,
                zoomToBoundsOnClick: true,
                disableClusteringAtZoom: 14,
                iconCreateFunction: function(cluster) {
                    const childCount = cluster.getChildCount();
                    let className = 'marker-cluster-small';
                    if (childCount > 100) {
                        className = 'marker-cluster-large';
                    } else if (childCount > 20) {
                        className = 'marker-cluster-medium';
                    }
                    
                    return L.divIcon({
                        html: '<div><span>' + childCount + '</span></div>',
                        className: 'marker-cluster ' + className,
                        iconSize: L.point(40, 40)
                    });
                }
            });
            
            polygonClusterGroup = L.markerClusterGroup({
                chunkedLoading: true,
                maxClusterRadius: 80,
                spiderfyOnMaxZoom: false,
                showCoverageOnHover: false,
                zoomToBoundsOnClick: true,
                disableClusteringAtZoom: 14,
                iconCreateFunction: function(cluster) {
                    const childCount = cluster.getChildCount();
                    let className = 'marker-cluster-small';
                    if (childCount > 100) {
                        className = 'marker-cluster-large';
                    } else if (childCount > 20) {
                        className = 'marker-cluster-medium';
                    }
                    
                    return L.divIcon({
                        html: '<div><span>' + childCount + '</span></div>',
                        className: 'marker-cluster ' + className,
                        iconSize: L.point(40, 40)
                    });
                }
            });
            initializeDeforestationLayer();
            const overlayMaps = getOverlayMaps();
            layerControl = L.control.layers(baseLayers, overlayMaps, { collapsed: false }).addTo(map);
            document.getElementById('deforestationControls').classList.remove('hidden');
            document.getElementById('mapLegend').classList.remove('hidden');
            document.getElementById('topControls').classList.remove('hidden');
            map.on('zoomend', updateLayersByZoom);
            map.on('baselayerchange', function(e) {
                currentBaseLayer = e.layer;
                ensureTreeLossLayerOnTop();
            });
            
            // Restore focus to map container on any layer control interaction to keep keyboard shortcuts working
            const layerControlContainer = layerControl.getContainer();
            layerControlContainer.addEventListener('click', function() {
                // Use setTimeout to ensure focus is set after Leaflet processes the click
                setTimeout(() => {
                    map.getContainer().focus();
                }, 0);
            });
            document.getElementById('controlsToggle').addEventListener('click', function() {
                const legend = document.getElementById('mapLegend');
                const controls = document.getElementById('deforestationControls');
                const button = document.getElementById('controlsToggle');
                if (legend.classList.contains('hidden')) {
                    legend.classList.remove('hidden');
                    controls.classList.remove('hidden');
                    button.textContent = getText('hideControls');
                } else {
                    legend.classList.add('hidden');
                    controls.classList.add('hidden');
                    button.textContent = getText('showControls');
                }
            });
            
            document.getElementById('startOverButton').addEventListener('click', function() {
                location.reload();
            });
        }

        function ensureTreeLossLayerOnTop() {
            // If treeLossLayer exists, ensure it's on the map and on top
            if (treeLossLayer) {
                const zoom = map.getZoom();
                // Only show at zoom >= 4
                if (zoom >= 4) {
                    if (!map.hasLayer(treeLossLayer)) {
                        treeLossLayer.addTo(map);
                    } else {
                        treeLossLayer.bringToFront();
                    }
                }
            }
        }

        function initializeFileUpload() {
            const dropArea = document.getElementById('fileDropArea');
            const fileInput = document.getElementById('fileInput');
            const fileSelectButton = document.getElementById('fileSelectButton');
            const welcomeOverlay = document.getElementById('welcomeOverlay');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // File select button click
            fileSelectButton.addEventListener('click', function() {
                fileInput.click();
            });

            // File input change event
            fileInput.addEventListener('change', function() {
                if (this.files.length > 0) {
                    handleFile(this.files[0]);
                }
            });

            // Drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                dropArea.classList.add('is-active');
            }

            function unhighlight() {
                dropArea.classList.remove('is-active');
            }

            // Handle dropped file
            dropArea.addEventListener('drop', function(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            // Handle the uploaded file
            function handleFile(file) {
                // Show loading overlay
                hideWelcomeOverlay();
                loadingOverlay.style.display = 'flex';
                // Initialize the map if not already done
                if (!map) {
                    initializeMap();
                }

                // Read the file
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const geoJSON = JSON.parse(e.target.result);
                        
                        // Process GeoJSON data (will normalize and validate)
                        processGeoJSON(geoJSON);

                        // Hide loading overlay
                        loadingOverlay.style.display = 'none';
                    } catch (error) {
                        console.error('Error processing GeoJSON:', error);
                        alert(getText('invalidGeoJSON') + '\n' + error.message);
                        
                        // Show welcome overlay again on error
                        showWelcomeOverlay();
                        loadingOverlay.style.display = 'none';
                    }
                };
                reader.readAsText(file);
            }
        }

        function normalizeGeoJSON(geoJSON) {
            // Normalize any valid GeoJSON format to a FeatureCollection
            if (!geoJSON || typeof geoJSON !== 'object') {
                throw new Error('Invalid GeoJSON: must be an object');
            }
            
            // Already a FeatureCollection
            if (geoJSON.type === 'FeatureCollection') {
                return geoJSON;
            }
            
            // Single Feature
            if (geoJSON.type === 'Feature') {
                return {
                    type: 'FeatureCollection',
                    features: [geoJSON]
                };
            }
            
            // GeometryCollection
            if (geoJSON.type === 'GeometryCollection' && geoJSON.geometries) {
                return {
                    type: 'FeatureCollection',
                    features: geoJSON.geometries.map(geom => ({
                        type: 'Feature',
                        geometry: geom,
                        properties: {}
                    }))
                };
            }
            
            // Just a Geometry (Point, LineString, Polygon, etc.)
            if (geoJSON.type && geoJSON.coordinates) {
                return {
                    type: 'FeatureCollection',
                    features: [{
                        type: 'Feature',
                        geometry: geoJSON,
                        properties: {}
                    }]
                };
            }
            
            throw new Error('Invalid GeoJSON: unrecognized format');
        }

        function processGeoJSON(geoJSON) {
            // Normalize the GeoJSON to a FeatureCollection format
            const normalizedGeoJSON = normalizeGeoJSON(geoJSON);
            
            // Store the current GeoJSON data
            currentGeoJSON = normalizedGeoJSON;
            
            // Clear existing layers
            polygonLayer.clearLayers();
            pointLayer.clearLayers();
            pointMarkerLayer.clearLayers();
            polygonMarkerLayer.clearLayers();
            
            // Clear cluster groups
            if (pointClusterGroup) {
                pointClusterGroup.clearLayers();
            }
            if (polygonClusterGroup) {
                polygonClusterGroup.clearLayers();
            }
            
            // Calculate bounds to fit the map to the data
            let bounds = null;
            
            // Count features for performance optimization
            const featureCount = normalizedGeoJSON.features ? normalizedGeoJSON.features.length : 0;
            const useClustering = featureCount > 1000; // Enable clustering for datasets with more than 1000 features
            
            // Process each feature in the GeoJSON
            if (normalizedGeoJSON.features && normalizedGeoJSON.features.length > 0) {
                normalizedGeoJSON.features.forEach(function(feature) {
                    // Get feature bounds
                    const featureBounds = getFeatureBounds(feature);
                    if (featureBounds) {
                        if (!bounds) {
                            bounds = featureBounds;
                        } else {
                            bounds.extend(featureBounds);
                        }
                    }
                    
                    if (feature.geometry) {
                        // Process based on geometry type
                        if (feature.geometry.type === 'Point') {
                            processPointFeature(feature, useClustering);
                        } else if (feature.geometry.type === 'MultiPoint') {
                            processMultiPointFeature(feature, useClustering);
                        } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                            processPolygonFeature(feature, useClustering);
                        }
                    }
                });
                
                // Fit map to data bounds if available
                if (bounds) {
                    map.fitBounds(bounds);
                }
                
                // Add cluster groups to map if they have markers and clustering is enabled
                if (useClustering) {
                    if (pointClusterGroup && pointClusterGroup.getLayers().length > 0) {
                        map.addLayer(pointClusterGroup);
                    }
                    if (polygonClusterGroup && polygonClusterGroup.getLayers().length > 0) {
                        map.addLayer(polygonClusterGroup);
                    }
                }
                
                // Update layers based on current zoom
                updateLayersByZoom();
            }
            
            // Make sure tree loss layer stays on top
            ensureTreeLossLayerOnTop();
        }
        
        function isValidNumber(n) {
            return typeof n === 'number' && !isNaN(n) && isFinite(n);
        }

        function toLatLngFromXY(x, y) {
            const lng = typeof x === 'string' ? parseFloat(x) : x;
            const lat = typeof y === 'string' ? parseFloat(y) : y;
            if (!isValidNumber(lat) || !isValidNumber(lng)) return null;
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return null;
            return L.latLng(lat, lng);
        }

        function getFeatureBounds(feature) {
            if (!feature.geometry) return null;
            
            if (feature.geometry.type === 'Point') {
                const coords = feature.geometry.coordinates;
                if (!coords || coords.length < 2) return null;
                const latLng = toLatLngFromXY(coords[0], coords[1]);
                if (!latLng) return null;
                return L.latLngBounds([latLng]);
            } else if (feature.geometry.type === 'MultiPoint') {
                const latLngs = [];
                if (feature.geometry.coordinates && Array.isArray(feature.geometry.coordinates)) {
                    feature.geometry.coordinates.forEach(coords => {
                        if (coords && coords.length >= 2) {
                            const latLng = toLatLngFromXY(coords[0], coords[1]);
                            if (latLng) latLngs.push(latLng);
                        }
                    });
                }
                return latLngs.length ? L.latLngBounds(latLngs) : null;
            } else if (feature.geometry.type === 'Polygon') {
                const ring = feature.geometry.coordinates && feature.geometry.coordinates[0] ? feature.geometry.coordinates[0] : [];
                const latLngs = [];
                for (let i = 0; i < ring.length; i++) {
                    const coord = ring[i];
                    if (coord && coord.length >= 2) {
                        const latLng = toLatLngFromXY(coord[0], coord[1]);
                        if (latLng) latLngs.push(latLng);
                    }
                }
                if (latLngs.length === 0) return null;
                return L.latLngBounds(latLngs);
            } else if (feature.geometry.type === 'MultiPolygon') {
                let allLatLngs = [];
                feature.geometry.coordinates.forEach(polygon => {
                    if (!polygon || !polygon[0]) return;
                    polygon[0].forEach(coord => {
                        if (coord && coord.length >= 2) {
                            const latLng = toLatLngFromXY(coord[0], coord[1]);
                            if (latLng) allLatLngs.push(latLng);
                        }
                    });
                });
                return allLatLngs.length ? L.latLngBounds(allLatLngs) : null;
            }
            
            return null;
        }
        
        function processPointFeature(feature, useClustering = true) {
            const coords = feature.geometry.coordinates;
            if (!coords || coords.length < 2) return;
            const latLng = toLatLngFromXY(coords[0], coords[1]);
            if (!latLng) return; // skip invalid
            
            // Create a marker for zoom levels <= 13
            const marker = L.marker(latLng);
            
            // Add popup with feature properties
            const popupContent = createPopupContent(feature.properties, 'Point');
            marker.bindPopup(popupContent);
            
            // Add marker to cluster group for better performance with large datasets
            if (useClustering && pointClusterGroup) {
                pointClusterGroup.addLayer(marker);
            } else {
                // Use regular layer for smaller datasets or when clustering is disabled
                pointMarkerLayer.addLayer(marker);
            }
            
            // Create circle representation with accurate area for zoom levels > 13
            let detailedRepresentationAdded = false;
            if (feature.properties && feature.properties.Area !== undefined) {
                // Get the area in hectares (robust parsing for commas, spaces, fractions, and unit suffixes)
                const areaHectares = parseAreaHectares(feature.properties.Area);
                if (isValidNumber(areaHectares) && areaHectares > 0) {
                    // Create an accurate area circle that will be resized with zoom level
                    const areaCircle = L.circle(latLng, {
                        className: 'area-circle'
                    });
                    
                    // Store the area in hectares as a property of the circle
                    areaCircle.areaHectares = areaHectares;
                    
                    // Add popup with feature properties
                    areaCircle.bindPopup(popupContent);
                    
                    // Add to the point layer (will be shown at zoom levels > 13)
                    pointLayer.addLayer(areaCircle);
                    detailedRepresentationAdded = true;
                }
            }

            // If there is no valid Area, add a default-sized circle marker so it remains visible at high zoom
            if (!detailedRepresentationAdded) {
                const circleMarker = L.circleMarker(latLng, {
                    radius: 6,
                    color: '#3388ff',
                    weight: 2,
                    opacity: 0.9,
                    fillColor: '#3388ff',
                    fillOpacity: 0.6
                });
                circleMarker.bindPopup(popupContent);
                pointLayer.addLayer(circleMarker);
            }
        }
        
        function processMultiPointFeature(feature, useClustering = true) {
            // MultiPoint contains an array of Point coordinates
            const coordinates = feature.geometry.coordinates;
            if (!coordinates || !Array.isArray(coordinates)) return;
            
            // Create the popup content once, shared by all points in this MultiPoint feature
            const popupContent = createPopupContent(feature.properties, 'MultiPoint');
            
            // Process each point in the MultiPoint
            coordinates.forEach((coords, index) => {
                if (!coords || coords.length < 2) return;
                const latLng = toLatLngFromXY(coords[0], coords[1]);
                if (!latLng) return; // skip invalid coordinates
                
                // Create a marker for zoom levels <= 13
                const marker = L.marker(latLng);
                marker.bindPopup(popupContent);
                
                // Add marker to cluster group for better performance with large datasets
                if (useClustering && pointClusterGroup) {
                    pointClusterGroup.addLayer(marker);
                } else {
                    pointMarkerLayer.addLayer(marker);
                }
                
                // Create detailed representation for zoom levels > 13
                let detailedRepresentationAdded = false;
                
                // Check if there's an Area property for this specific point
                // Some MultiPoint features might have an array of areas
                let areaValue = null;
                if (feature.properties) {
                    // Try to find area for this specific point (check for array of areas)
                    if (feature.properties.Areas && Array.isArray(feature.properties.Areas) && feature.properties.Areas[index] !== undefined) {
                        areaValue = feature.properties.Areas[index];
                    } 
                    // Otherwise use single Area property (applies to all points)
                    else if (feature.properties.Area !== undefined) {
                        areaValue = feature.properties.Area;
                    }
                }
                
                if (areaValue !== null) {
                    const areaHectares = parseAreaHectares(areaValue);
                    if (isValidNumber(areaHectares) && areaHectares > 0) {
                        // Create an accurate area circle that will be resized with zoom level
                        const areaCircle = L.circle(latLng, {
                            className: 'area-circle'
                        });
                        
                        // Store the area in hectares as a property of the circle
                        areaCircle.areaHectares = areaHectares;
                        areaCircle.bindPopup(popupContent);
                        pointLayer.addLayer(areaCircle);
                        detailedRepresentationAdded = true;
                    }
                }
                
                // If there is no valid Area, add a default-sized circle marker so it remains visible at high zoom
                if (!detailedRepresentationAdded) {
                    const circleMarker = L.circleMarker(latLng, {
                        radius: 6,
                        color: '#3388ff',
                        weight: 2,
                        opacity: 0.9,
                        fillColor: '#3388ff',
                        fillOpacity: 0.6
                    });
                    circleMarker.bindPopup(popupContent);
                    pointLayer.addLayer(circleMarker);
                }
            });
        }
        
        function processPolygonFeature(feature, useClustering = true) {
            // Determine geometry type for popup title
            const geometryType = feature.geometry.type;
            
            // Create the polygon
            const geoJSONLayer = L.geoJSON(feature, {
                style: function() {
                    return {
                        fillColor: '#3388ff',
                        weight: 2,
                        opacity: 0.8,
                        color: '#3388ff',
                        fillOpacity: 0.15
                    };
                },
                onEachFeature: function(feature, layer) {
                    // Add popup with feature properties
                    const popupContent = createPopupContent(feature.properties, geometryType);
                    layer.bindPopup(popupContent);
                }
            });
            
            // Add polygon to the polygon layer
            polygonLayer.addLayer(geoJSONLayer);
            
            // Create the popup content once, shared by all markers for this feature
            const popupContent = createPopupContent(feature.properties, geometryType);
            
            // Calculate centroid(s) for marker representation
            try {
                if (feature.geometry.type === 'Polygon') {
                    // Validate polygon coordinates structure
                    if (feature.geometry.coordinates && 
                        feature.geometry.coordinates.length > 0 && 
                        feature.geometry.coordinates[0] && 
                        feature.geometry.coordinates[0].length > 0) {
                        const centroid = calculatePolygonCentroid(feature.geometry.coordinates[0]);
                        if (centroid && centroid.length === 2 && isValidNumber(centroid[0]) && isValidNumber(centroid[1])) {
                            createPolygonMarker(centroid, popupContent, useClustering);
                        }
                    }
                } else if (feature.geometry.type === 'MultiPolygon') {
                    // Process each polygon in the MultiPolygon
                    if (feature.geometry.coordinates && Array.isArray(feature.geometry.coordinates)) {
                        feature.geometry.coordinates.forEach(polygon => {
                            // Validate each polygon's coordinates structure
                            if (polygon && 
                                polygon.length > 0 && 
                                polygon[0] && 
                                polygon[0].length > 0) {
                                const centroid = calculatePolygonCentroid(polygon[0]);
                                if (centroid && centroid.length === 2 && isValidNumber(centroid[0]) && isValidNumber(centroid[1])) {
                                    createPolygonMarker(centroid, popupContent, useClustering);
                                }
                            }
                        });
                    }
                }
            } catch (e) {
                console.error('Error creating centroid for feature:', feature, e);
            }
        }
        
        function createPolygonMarker(centroid, popupContent, useClustering) {
            // Create a marker at the centroid
            const marker = L.marker([centroid[1], centroid[0]]);
            marker.bindPopup(popupContent);
            
            // Add to cluster group for better performance with large datasets
            if (useClustering && polygonClusterGroup) {
                polygonClusterGroup.addLayer(marker);
            } else {
                // Use regular layer for smaller datasets or when clustering is disabled
                polygonMarkerLayer.addLayer(marker);
            }
        }
        
        function calculatePolygonCentroid(coordinates) {
            // Simple centroid calculation for a polygon
            if (!coordinates || !Array.isArray(coordinates) || coordinates.length === 0) {
                return null;
            }
            
            let x = 0;
            let y = 0;
            let numPoints = 0;
            
            for (let i = 0; i < coordinates.length; i++) {
                const coord = coordinates[i];
                if (coord && Array.isArray(coord) && coord.length >= 2 && 
                    !isNaN(coord[0]) && !isNaN(coord[1])) {
                    x += coord[0];
                    y += coord[1];
                    numPoints++;
                }
            }
            
            if (numPoints === 0) {
                return null;
            }
            
            return [x / numPoints, y / numPoints];
        }
        
        // Escapes text for safe HTML insertion in popups
        function escapeHtml(unsafeText) {
            if (unsafeText === null || unsafeText === undefined) return '';
            return String(unsafeText)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Formats property values into readable strings before escaping
        function formatPropertyValue(value) {
            if (value === null || value === undefined) return '';
            const valueType = typeof value;
            if (valueType === 'string' || valueType === 'number' || valueType === 'boolean') {
                return String(value);
            }
            try {
                return JSON.stringify(value);
            } catch (e) {
                return String(value);
            }
        }

        // Validates if a string is a safe, clickable URL
        function isValidUrl(value) {
            if (!value || typeof value !== 'string') return false;
            
            const trimmed = value.trim();
            
            // Quick check for http/https prefix
            if (!trimmed.startsWith('http://') && !trimmed.startsWith('https://')) {
                return false;
            }
            
            // Validate URL structure using URL constructor
            try {
                const url = new URL(trimmed);
                // Additional security: only allow http and https protocols
                if (url.protocol !== 'http:' && url.protocol !== 'https:') {
                    return false;
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        // Creates a secure clickable link with proper attributes
        function createSafeLink(url) {
            // Double-check URL validity
            if (!isValidUrl(url)) {
                return escapeHtml(url);
            }
            
            const trimmedUrl = url.trim();
            
            // Escape the URL for safe insertion in href attribute
            // encodeURI handles special characters while preserving URL structure
            const safeHref = encodeURI(trimmedUrl);
            
            // For display, show truncated version if URL is very long
            let displayText = trimmedUrl;
            if (trimmedUrl.length > 50) {
                displayText = trimmedUrl.substring(0, 47) + '...';
            }
            
            // Escape the display text for safe HTML insertion
            const safeDisplayText = escapeHtml(displayText);
            
            // Create link with security attributes:
            // - target="_blank": opens in new tab
            // - rel="noopener noreferrer": prevents window.opener access and referrer leaking
            return `<a href="${safeHref}" target="_blank" rel="noopener noreferrer">${safeDisplayText}</a>`;
        }

        // Parses area values robustly, supporting thousand separators, decimal commas, spaces, and simple fractions like "1/2"
        function parseAreaHectares(raw) {
            if (raw === null || raw === undefined) return NaN;
            if (typeof raw === 'number') return raw;
            let text = String(raw).trim();
            if (text.length === 0) return NaN;

            // Handle simple fractions like "3/4"
            const fractionMatch = text.match(/^\s*(-?\d+)\s*\/\s*(\d+)\s*$/);
            if (fractionMatch) {
                const numerator = parseFloat(fractionMatch[1]);
                const denominator = parseFloat(fractionMatch[2]);
                if (denominator !== 0) return numerator / denominator;
            }

            // Remove non-numeric unit suffixes (e.g., " ha", "hectares") while preserving digits, separators, and signs
            text = text.replace(/[^0-9.,\-\s']/g, '');

            // Normalize various thousand separators (spaces, apostrophes, thin spaces)
            text = text.replace(/[\s'\u00A0\u202F]/g, '');

            // If we have both comma and dot, assume comma is thousands separator ‚Üí remove commas
            if (text.indexOf(',') !== -1 && text.indexOf('.') !== -1) {
                text = text.replace(/,/g, '');
            } else if (text.indexOf(',') !== -1 && text.indexOf('.') === -1) {
                // Only comma present ‚Üí treat comma as decimal separator
                text = text.replace(/,/g, '.');
            }

            const parsed = parseFloat(text);
            return isNaN(parsed) ? NaN : parsed;
        }

        function createPopupContent(properties, geometryType) {
            if (!properties) return getText('noProperties');
            
            // Format the title with geometry type
            let title = geometryType ? geometryType + ' ' + getText('propertiesTitle') : getText('propertiesTitle');
            
            let content = '<div class="info-box">';
            content += '<div class="info-title">' + escapeHtml(title) + '</div>';
            content += '<div class="info-content">';
            
            // Add each property to the popup
            Object.keys(properties).forEach(function(key) {
                const value = properties[key];
                const safeKey = escapeHtml(key);
                
                // Format the value first
                const formattedValue = formatPropertyValue(value);
                
                // Check if the formatted value is a valid URL
                let safeValue;
                if (isValidUrl(formattedValue)) {
                    // Create a clickable link for valid URLs
                    safeValue = createSafeLink(formattedValue);
                } else {
                    // Escape as plain text for non-URLs
                    safeValue = escapeHtml(formattedValue);
                }
                
                content += `<strong>${safeKey}:</strong> ${safeValue}<br>`;
            });
            
            content += '</div></div>';
            return content;
        }
        
        function updateLayersByZoom() {
            if (!map) return;
            
            const zoom = map.getZoom();
            
            // Handle TreeLossLayer visibility based on zoom level
            if (treeLossLayer) {
                if (zoom >= 4 && !map.hasLayer(treeLossLayer)) {
                    treeLossLayer.addTo(map);
                } else if (zoom < 4 && map.hasLayer(treeLossLayer)) {
                    map.removeLayer(treeLossLayer);
                }
            }
            
            // For zoom levels <= 13, show marker representations (clustered for performance)
            if (zoom <= 13) {
                map.removeLayer(polygonLayer);
                map.removeLayer(pointLayer);
                
                // Check if we have cluster groups with markers
                const hasPointClusters = pointClusterGroup && pointClusterGroup.getLayers().length > 0;
                const hasPolygonClusters = polygonClusterGroup && polygonClusterGroup.getLayers().length > 0;
                
                if (hasPointClusters || hasPolygonClusters) {
                    // Remove regular marker layers if they exist
                    if (map.hasLayer(pointMarkerLayer)) map.removeLayer(pointMarkerLayer);
                    if (map.hasLayer(polygonMarkerLayer)) map.removeLayer(polygonMarkerLayer);
                    
                    // Add cluster groups for better performance
                    if (hasPointClusters && !map.hasLayer(pointClusterGroup)) {
                        map.addLayer(pointClusterGroup);
                    }
                    if (hasPolygonClusters && !map.hasLayer(polygonClusterGroup)) {
                        map.addLayer(polygonClusterGroup);
                    }
                } else {
                    // Use regular marker layers for smaller datasets
                    if (map.hasLayer(pointClusterGroup)) map.removeLayer(pointClusterGroup);
                    if (map.hasLayer(polygonClusterGroup)) map.removeLayer(polygonClusterGroup);
                    
                    if (!map.hasLayer(pointMarkerLayer)) map.addLayer(pointMarkerLayer);
                    if (!map.hasLayer(polygonMarkerLayer)) map.addLayer(polygonMarkerLayer);
                }
            } 
            // For zoom levels > 15, show detailed representations
            else {
                // Remove cluster groups
                if (pointClusterGroup && map.hasLayer(pointClusterGroup)) {
                    map.removeLayer(pointClusterGroup);
                }
                if (polygonClusterGroup && map.hasLayer(polygonClusterGroup)) {
                    map.removeLayer(polygonClusterGroup);
                }
                
                // Add detailed layers
                if (!map.hasLayer(polygonLayer)) map.addLayer(polygonLayer);
                if (!map.hasLayer(pointLayer)) map.addLayer(pointLayer);

                // Ensure feature markers (pointMarkerLayer, polygonMarkerLayer) are hidden at high zoom
                if (map.hasLayer(pointMarkerLayer)) map.removeLayer(pointMarkerLayer);
                if (map.hasLayer(polygonMarkerLayer)) map.removeLayer(polygonMarkerLayer);
                
                // Update circle radii to represent actual areas in hectares
                updateCircleRadii();
            }
            
            // Ensure tree loss layer is on top
            ensureTreeLossLayerOnTop();
        }
        
        function updateCircleRadii() {
            pointLayer.eachLayer(function(layer) {
                if (layer.areaHectares !== undefined) {
                    // Convert hectares to square meters (1 hectare = 10000 square meters)
                    const areaSquareMeters = layer.areaHectares * 10000;
                    
                    // Calculate radius from area: area = œÄ √ó radius¬≤
                    // Therefore, radius = sqrt(area / œÄ)
                    const radius = Math.sqrt(areaSquareMeters / Math.PI);
                    
                    // Set the circle radius
                    layer.setRadius(radius);
                }
            });
        }

        // Global Forest Watch Deforestation Layer Implementation
        function initializeDeforestationLayer() {
            // Define the TreeLossLayer class
            const TreeLossLayer = L.TileLayer.extend({
                options: {
                    maxZoom: 19,
                    minZoom: 0
                },
				createTile: function(coords, done) {
					const nativeZoom = 12;
					const canvas = document.createElement('canvas');
					const size = this.getTileSize();
					canvas.width = size.x;
					canvas.height = size.y;
					const ctx = canvas.getContext('2d');
					ctx.imageSmoothingEnabled = false;

					// If we're at or below native zoom, use the tile directly
					if (coords.z <= nativeZoom) {
						const img = new Image();
						img.crossOrigin = 'Anonymous';
						img.src = `https://tiles.globalforestwatch.org/umd_tree_cover_loss/v1.12/dynamic/${coords.z}/${coords.x}/${coords.y}.png?tree_cover_density_threshold=30`;

						img.onload = () => {
							// Draw the full image
							ctx.drawImage(img, 0, 0, size.x, size.y);
							this.processImageData(ctx, size, done, canvas);
						};

						img.onerror = (err) => {
							console.error('Tile load error:', coords, err);
							done(null, canvas);
						};
					} else {
						// For zoom levels higher than native, we need to scale up from a parent tile
						const scale = Math.pow(2, coords.z - nativeZoom);
						const parentX = Math.floor(coords.x / scale);
						const parentY = Math.floor(coords.y / scale);
						
						// Calculate which part of the parent tile we need
						const xOff = (coords.x % scale) / scale;
						const yOff = (coords.y % scale) / scale;
						const tileScale = 1 / scale;

						const img = new Image();
						img.crossOrigin = 'Anonymous';
						img.src = `https://tiles.globalforestwatch.org/umd_tree_cover_loss/v1.12/dynamic/${nativeZoom}/${parentX}/${parentY}.png?tree_cover_density_threshold=30`;

						img.onload = () => {
							// Calculate source rectangle within the parent tile
							const srcX = xOff * img.width;
							const srcY = yOff * img.height;
							const srcWidth = img.width * tileScale;
							const srcHeight = img.height * tileScale;

							// Draw the appropriate section, scaling it up to fill our canvas
							ctx.drawImage(
								img,
								srcX, srcY, srcWidth, srcHeight,
								0, 0, size.x, size.y
							);
							
							this.processImageData(ctx, size, done, canvas);
						};

						img.onerror = (err) => {
							console.error('Tile load error:', coords, err);
							done(null, canvas);
						};
					}

					return canvas;
				},

				processImageData: function(ctx, size, done, canvas) {
					// Process the image data for year filtering
					const imageData = ctx.getImageData(0, 0, size.x, size.y);
					const data = imageData.data;
					
					for (let i = 0; i < data.length; i += 4) {
						const red = data[i];
						const blue = data[i + 2];
						
						if (red > 0) {
							const year = blue;
							if (activeYears[year]) {
								const c = this._hexToRgb(getYearColor(year));
								data[i]     = c.r;
								data[i + 1] = c.g;
								data[i + 2] = c.b;
								data[i + 3] = 200; // Set opacity
							} else {
								data[i + 3] = 0; // Make transparent
							}
						} else {
							data[i + 3] = 0; // Make transparent if no loss
						}
					}
					
					ctx.putImageData(imageData, 0, 0);
					done(null, canvas);
				},

				_hexToRgb: function(hex) {
					hex = hex.replace('#','');
					return {
						r: parseInt(hex.slice(0,2), 16),
						g: parseInt(hex.slice(2,4), 16),
						b: parseInt(hex.slice(4,6), 16)
					};
				}
			});


            // Define color scale for years
            const getYearColor = function(year) {
                // A color scale from red to yellow
                const colors = {
                    1: '#FFff00',  // 2001
                    2: '#FFff00',  // 2002
                    3: '#FFee00',  // 2003
                    4: '#FFee00',  // 2004
                    5: '#FFdd00',  // 2005
                    6: '#FFdd00',  // 2006
                    7: '#FFcc00',  // 2007
                    8: '#FFcc00',  // 2008
                    9: '#FFbb00',  // 2009
                    10: '#FFbb00', // 2010
                    11: '#FFaa00', // 2011
                    12: '#FFaa00', // 2012
                    13: '#FF9900', // 2013
                    14: '#FF9900', // 2014
                    15: '#FF8800', // 2015
                    16: '#FF8800', // 2016
                    17: '#FF7700', // 2017
                    18: '#FF7700', // 2018
                    19: '#FF6600', // 2019
                    20: '#FF6600', // 2020
                    21: '#FF2200', // 2021
                    22: '#FF1100', // 2022
                    23: '#FF0800',  // 2023
					24: '#FF0000' // 2024
                };
                
                return colors[year] || '#FF0000';
            };

            // Initialize activeYears with years 2021 and later active
            for (let year = 1; year <= 24; year++) {
                activeYears[year] = (year >= 21); // Only years 2021+ start active
            }

                         // Create tree loss layer
             treeLossLayer = new TreeLossLayer({
                 attribution: '<a href="https://www.globalforestwatch.org/blog/data-and-tools/2024-tree-cover-loss-data-explained/">Global Forest Watch | UMD GFC v1.12</a>',
                 tileSize: 256,
                 minZoom: 3,
                 maxZoom: 19,
                 maxNativeZoom: 12,
                 noWrap: true,
                 zIndex: 1000, // High z-index to keep it on top
                 pane: 'overlayPane' // Use the overlay pane for this layer
             });
             
             // Only add to map if current zoom is >= minZoom
             if (map.getZoom() >= 3) {
                 treeLossLayer.addTo(map);
             }

            // Manually add attribution to the map's attribution control
            if (map.attributionControl) {
                map.attributionControl.addAttribution('<a href="https://www.globalforestwatch.org/blog/data-and-tools/2024-tree-cover-loss-data-explained/">Global Forest Watch | UMD GFC v1.12</a>');
            }

            // Setup deforestation year controls
            setupDeforestationControls();

            // Initialize legend
            updateLegend();
        }

        function setupDeforestationControls() {
            // Create buttons for each year
            const yearButtonsContainer = document.getElementById('year-buttons');
            for (let year = 1; year <= 24; year++) {
                const actualYear = 2000 + year;
                const button = document.createElement('button');
                button.textContent = actualYear;
                button.id = `btn-year-${year}`;
                button.className = activeYears[year] ? 'active' : '';
                
                button.addEventListener('click', () => {
                    // Toggle this year
                    activeYears[year] = !activeYears[year];
                    button.className = activeYears[year] ? 'active' : '';
                    updateDeforestationLayer();
                });
                
                yearButtonsContainer.appendChild(button);
            }
            
            // Handle group control buttons
            document.getElementById('btn-all-years').addEventListener('click', () => {
                // Set all years active
                for (let year = 1; year <= 24; year++) {
                    activeYears[year] = true;
                    document.getElementById(`btn-year-${year}`).className = 'active';
                }
                
                // Update button states
                document.getElementById('btn-all-years').className = 'active';
                document.getElementById('btn-before-2021').className = '';
                document.getElementById('btn-2021-onwards').className = '';
                document.getElementById('btn-clear-all').className = '';
                document.getElementById('btn-custom').className = '';
                
                // Hide individual years section
                document.getElementById('individualYearsSection').classList.add('hidden');
                
                updateDeforestationLayer();
            });
            
            document.getElementById('btn-before-2021').addEventListener('click', () => {
                // Set only pre-2021 years active
                for (let year = 1; year <= 24; year++) {
                    activeYears[year] = (year < 21);
                    document.getElementById(`btn-year-${year}`).className = activeYears[year] ? 'active' : '';
                }
                
                // Update button states
                document.getElementById('btn-all-years').className = '';
                document.getElementById('btn-before-2021').className = 'active';
                document.getElementById('btn-2021-onwards').className = '';
                document.getElementById('btn-clear-all').className = '';
                document.getElementById('btn-custom').className = '';
                
                // Hide individual years section
                document.getElementById('individualYearsSection').classList.add('hidden');
                
                updateDeforestationLayer();
            });
            
            document.getElementById('btn-2021-onwards').addEventListener('click', () => {
                // Set only 2021+ years active
                for (let year = 1; year <= 24; year++) {
                    activeYears[year] = (year >= 21);
                    document.getElementById(`btn-year-${year}`).className = activeYears[year] ? 'active' : '';
                }
                
                // Update button states
                document.getElementById('btn-all-years').className = '';
                document.getElementById('btn-before-2021').className = '';
                document.getElementById('btn-2021-onwards').className = 'active';
                document.getElementById('btn-clear-all').className = '';
                document.getElementById('btn-custom').className = '';
                
                // Hide individual years section
                document.getElementById('individualYearsSection').classList.add('hidden');
                
                updateDeforestationLayer();
            });
            
            document.getElementById('btn-clear-all').addEventListener('click', () => {
                // Clear all years
                for (let year = 1; year <= 24; year++) {
                    activeYears[year] = false;
                    document.getElementById(`btn-year-${year}`).className = '';
                }
                
                // Update button states
                document.getElementById('btn-all-years').className = '';
                document.getElementById('btn-before-2021').className = '';
                document.getElementById('btn-2021-onwards').className = '';
                document.getElementById('btn-clear-all').className = 'active';
                document.getElementById('btn-custom').className = '';
                
                // Hide individual years section
                document.getElementById('individualYearsSection').classList.add('hidden');
                
                updateDeforestationLayer();
            });
            
            document.getElementById('btn-custom').addEventListener('click', () => {
                // Update button states
                document.getElementById('btn-all-years').className = '';
                document.getElementById('btn-before-2021').className = '';
                document.getElementById('btn-2021-onwards').className = '';
                document.getElementById('btn-clear-all').className = '';
                document.getElementById('btn-custom').className = 'active';
                
                // Show individual years section
                document.getElementById('individualYearsSection').classList.remove('hidden');
            });
            
            // Spacebar keyboard shortcut to toggle between no overlay and 2021+ overlay
            document.addEventListener('keydown', (e) => {
                // Only trigger if no input fields are focused
                if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    return;
                }
                
                // Spacebar: Toggle between no tree loss overlay and 2021+ overlay
                if (e.code === 'Space') {
                    e.preventDefault(); // Prevent page scroll
                    
                    // Check if any years from 2021+ are currently active
                    const has2021Plus = activeYears[21] || activeYears[22] || activeYears[23] || activeYears[24];
                    
                    if (has2021Plus) {
                        // Turn off all years (like Clear All button)
                        for (let year = 1; year <= 24; year++) {
                            activeYears[year] = false;
                            document.getElementById(`btn-year-${year}`).className = '';
                        }
                        
                        // Update button states to show Clear All is active
                        document.getElementById('btn-all-years').className = '';
                        document.getElementById('btn-before-2021').className = '';
                        document.getElementById('btn-2021-onwards').className = '';
                        document.getElementById('btn-clear-all').className = 'active';
                        document.getElementById('btn-custom').className = '';
                        
                        // Hide individual years section
                        document.getElementById('individualYearsSection').classList.add('hidden');
                    } else {
                        // Turn on 2021+ years (like 2021 Onwards button)
                        for (let year = 1; year <= 24; year++) {
                            activeYears[year] = (year >= 21);
                            document.getElementById(`btn-year-${year}`).className = activeYears[year] ? 'active' : '';
                        }
                        
                        // Update button states to show 2021 Onwards is active
                        document.getElementById('btn-all-years').className = '';
                        document.getElementById('btn-before-2021').className = '';
                        document.getElementById('btn-2021-onwards').className = 'active';
                        document.getElementById('btn-clear-all').className = '';
                        document.getElementById('btn-custom').className = '';
                        
                        // Hide individual years section
                        document.getElementById('individualYearsSection').classList.add('hidden');
                    }
                    
                    updateDeforestationLayer();
                }
                
                // F key: Toggle Forest Coverage overlay
                if (e.code === 'KeyF') {
                    e.preventDefault();
                    
                    if (forestCoverageLayer) {
                        if (map.hasLayer(forestCoverageLayer)) {
                            map.removeLayer(forestCoverageLayer);
                        } else {
                            forestCoverageLayer.addTo(map);
                        }
                    }
                }
                
                // T key: Toggle between ESRI latest and ESRI 2020 base layers
                if (e.code === 'KeyT') {
                    e.preventDefault();
                    
                    // Get the base layer names
                    const satelliteLatestName = getText('satelliteLatest');
                    const satellite2020Name = getText('satellite2020');
                    
                    // Get the actual layer objects
                    const satelliteLatestLayer = baseLayers[satelliteLatestName];
                    const satellite2020Layer = baseLayers[satellite2020Name];
                    
                    // Check which ESRI layer is currently active (if any)
                    if (currentBaseLayer === satelliteLatestLayer) {
                        // Switch to ESRI 2020
                        map.removeLayer(satelliteLatestLayer);
                        satellite2020Layer.addTo(map);
                        currentBaseLayer = satellite2020Layer;
                    } else if (currentBaseLayer === satellite2020Layer) {
                        // Switch to ESRI latest
                        map.removeLayer(satellite2020Layer);
                        satelliteLatestLayer.addTo(map);
                        currentBaseLayer = satelliteLatestLayer;
                    } else {
                        // Not on an ESRI layer, switch to ESRI latest
                        map.removeLayer(currentBaseLayer);
                        satelliteLatestLayer.addTo(map);
                        currentBaseLayer = satelliteLatestLayer;
                    }
                    
                    // Ensure tree loss layer stays on top after base layer change
                    ensureTreeLossLayerOnTop();
                }
            });
        }

        function updateDeforestationLayer() {
            // Force a reload of the layer by removing and re-adding it
            if (map.hasLayer(treeLossLayer)) {
                map.removeLayer(treeLossLayer);
            }
            
            // Add it back
            treeLossLayer.addTo(map);
            
            // Update the legend
            updateLegend();
            
            // Ensure it stays on top
            ensureTreeLossLayerOnTop();
        }

        // Update legend based on active years
        function updateLegend() {
            const legendItems = document.getElementById('legend-items');
            
            // Clear existing legend items
            legendItems.innerHTML = '';
            
            // Add polygon legend item
            const polygonLegendItem = document.createElement('div');
            polygonLegendItem.className = 'legend-item';
            
            const polygonColorBox = document.createElement('div');
            polygonColorBox.className = 'legend-color';
            polygonColorBox.style.border = '2px solid #3388ff';
            polygonColorBox.style.backgroundColor = 'transparent';
            
            const polygonLabel = document.createElement('span');
            polygonLabel.textContent = getText('plotBoundary');
            
            polygonLegendItem.appendChild(polygonColorBox);
            polygonLegendItem.appendChild(polygonLabel);
            legendItems.appendChild(polygonLegendItem);
            
            // Check if any years from 2001-2020 are active
            let hasPreEUDR = false;
            for (let year = 1; year <= 20; year++) {
                if (activeYears[year]) {
                    hasPreEUDR = true;
                    break;
                }
            }
            
            // Check if any years from 2021-2024 are active
            let hasEUDR = false;
            for (let year = 21; year <= 24; year++) {
                if (activeYears[year]) {
                    hasEUDR = true;
                    break;
                }
            }
            
            // Add gradient legend item for 2001-2020 if any of those years are active
            if (hasPreEUDR) {
                const gradientLegendItem = document.createElement('div');
                gradientLegendItem.className = 'legend-item';
                
                const gradientColorBox = document.createElement('div');
                gradientColorBox.className = 'legend-color-gradient';
                
                const gradientLabel = document.createElement('span');
                gradientLabel.textContent = getText('treeCoverLoss2001_2020');
                
                gradientLegendItem.appendChild(gradientColorBox);
                gradientLegendItem.appendChild(gradientLabel);
                legendItems.appendChild(gradientLegendItem);
            }
            
            // Add red legend item for 2021-2024 if any of those years are active
            if (hasEUDR) {
                const eudrLegendItem = document.createElement('div');
                eudrLegendItem.className = 'legend-item';
                
                const eudrColorBox = document.createElement('div');
                eudrColorBox.className = 'legend-color';
                eudrColorBox.style.backgroundColor = '#FF0000';
                
                const eudrLabel = document.createElement('span');
                eudrLabel.textContent = getText('treeCoverLoss2021_2024');
                
                eudrLegendItem.appendChild(eudrColorBox);
                eudrLegendItem.appendChild(eudrLabel);
                legendItems.appendChild(eudrLegendItem);
            }
        }
        
        // Color function for deforestation years
        function getYearColor(year) {
            // A color scale from red to yellow to green to blue
            const colors = {
                    1: '#FFff00',  // 2001
                    2: '#FFff00',  // 2002
                    3: '#FFee00',  // 2003
                    4: '#FFee00',  // 2004
                    5: '#FFdd00',  // 2005
                    6: '#FFdd00',  // 2006
                    7: '#FFcc00',  // 2007
                    8: '#FFcc00',  // 2008
                    9: '#FFbb00',  // 2009
                    10: '#FFbb00', // 2010
                    11: '#FFaa00', // 2011
                    12: '#FFaa00', // 2012
                    13: '#FF9900', // 2013
                    14: '#FF9900', // 2014
                    15: '#FF8800', // 2015
                    16: '#FF8800', // 2016
                    17: '#FF7700', // 2017
                    18: '#FF7700', // 2018
                    19: '#FF6600', // 2019
                    20: '#FF6600', // 2020
                    21: '#FF2200', // 2021
                    22: '#FF1100', // 2022
                    23: '#FF0800',  // 2023
					24: '#FF0000' // 2024
            };
            
            return colors[year] || '#FF0000';
        }

        // Translation logic (copied and adapted from KML)
        let currentLanguage = 'en';
        let translations = {};
        function initializeTranslations() {
            translations.en = JSON.parse(document.getElementById('lang-en').textContent);
            translations.es = JSON.parse(document.getElementById('lang-es').textContent);
            translations.fr = JSON.parse(document.getElementById('lang-fr').textContent);
            translations.pt = JSON.parse(document.getElementById('lang-pt').textContent);
            translations.sw = JSON.parse(document.getElementById('lang-sw').textContent);
            translations.zh = JSON.parse(document.getElementById('lang-zh').textContent);
            translations.th = JSON.parse(document.getElementById('lang-th').textContent);
            translations.am = JSON.parse(document.getElementById('lang-am').textContent);
        }
        function changeLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('georoots-mapper-language', lang);
            document.documentElement.lang = lang;
            updateAllText();
            // Update layer control names if map is initialized
            if (typeof map !== 'undefined' && map) {
                if (layerControl) {
                    layerControl.remove();
                }
                // Remove all base layers from map
                Object.values(baseLayers).forEach(layer => {
                    if (map.hasLayer(layer)) map.removeLayer(layer);
                });
                baseLayers = getBaseLayers();
                // Add the first base layer back to the map if not present
                const firstBaseLayer = Object.values(baseLayers)[0];
                if (!map.hasLayer(firstBaseLayer)) firstBaseLayer.addTo(map);
                currentBaseLayer = firstBaseLayer;
                const overlayMaps = getOverlayMaps();
                layerControl = L.control.layers(baseLayers, overlayMaps, { collapsed: false }).addTo(map);
            }
        }
        function updateAllText() {
            const elements = document.querySelectorAll('[data-i18n]');
            elements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                const translation = translations[currentLanguage][key];
                if (translation) {
                    element.textContent = translation;
                }
            });
        }
        function getText(key, param) {
            let t = translations[currentLanguage][key] || translations.en[key] || key;
            if (param) t = t.replace('{year}', param);
            return t;
        }
    </script>
</body>
</html>
